# Руководство по стилю документации

Этот документ описывает единую стилистику для всех глав учебника `docs/book/*`. Цель — сделать документацию такой же простой и обучающей через практику, как лабораторные работы `labs/*/METHOD.md`.

## Философия

**Принцип:** Сначала интуиция и практика, потом формализация.

- **Простым языком** — избегаем академического жаргона без необходимости
- **Через примеры** — показываем, как это работает на практике
- **Ошибки как обучение** — типовые ошибки помогают понять концепцию глубже
- **Самопроверка** — мини-упражнения и чек-листы для закрепления

## Унифицированный шаблон главы

Каждая глава `docs/book/*/README.md` должна следовать этой структуре:

### 1. Зачем это нужно? (обязательно)

1-2 абзаца, объясняющие:
- Зачем читать эту главу
- Какую проблему она решает
- Почему это важно для создания агентов

**Пример:**
```markdown
## Зачем это нужно?

Function Calling превращает LLM из "болтуна" в "работника". Без инструментов агент может только отвечать текстом, но не может взаимодействовать с реальным миром.
```

### 2. Реальный кейс (обязательно)

Короткий сценарий из практики, показывающий проблему и решение.

**Формат:**
- **Ситуация:** Описание проблемы
- **Проблема:** Что не работает без этой концепции
- **Решение:** Как концепция решает проблему

**Пример:**
```markdown
### Реальный кейс

**Ситуация:** Пользователь пишет: "Проверь статус сервера web-01"
**Проблема:** Бот не может реально проверить сервер. Он только говорит.
**Решение:** Function Calling позволяет модели вызывать реальные функции Go.
```

### 3. Теория простыми словами (обязательно)

Интуитивное объяснение концепции без формализации. Используем аналогии и простые примеры.

**Правила:**
- Короткие абзацы (2-3 предложения)
- Избегаем математики в основном тексте
- Используем аналогии ("как в реальной жизни...")

**Пример:**
```markdown
## Теория простыми словами

### Как работает Function Calling?

1. Вы описываете функцию в формате JSON Schema
2. LLM видит описание и решает: "Мне нужно вызвать эту функцию"
3. LLM генерирует JSON с именем функции и аргументами
4. Ваш код парсит JSON и выполняет реальную функцию
5. Результат возвращается в LLM для дальнейшей обработки
```

### 4. Как это работает (пошагово) (обязательно)

Алгоритм или протокол работы. Показываем шаги с примерами кода.

**Формат:**
- Нумерованные шаги
- Минимальный пример кода на каждом шаге
- Комментарии объясняют, что происходит

**Пример:**
```markdown
## Алгоритм выполнения

### Шаг 1: Определение инструмента

```go
tools := []openai.Tool{
    {
        Type: openai.ToolTypeFunction,
        Function: &openai.FunctionDefinition{
            Name:        "get_server_status",
            Description: "Get the status of a server by IP address",
            // ...
        },
    },
}
```

**Важно:** `Description` — это самое важное поле! LLM ориентируется именно по нему.
```

### 5. Мини-пример кода (обязательно)

Полный рабочий пример, показывающий концепцию в действии.

**Правила:**
- Начинаем с минимального примера
- Затем расширяем, показывая более сложные случаи
- Комментарии объясняют каждый важный момент

### 6. Типовые ошибки (обязательно, минимум 3-5)

Формат: **Симптом → Причина → Решение**

**Шаблон:**
```markdown
### Ошибка N: [Название]

**Симптом:** [Что видит пользователь, когда что-то не так]

**Причина:** [Почему это происходит]

**Решение:**
```go
// ПЛОХО
// ...

// ХОРОШО
// ...
```
```

**Пример:**
```markdown
### Ошибка 1: История не сохраняется

**Симптом:** Агент не помнит предыдущие сообщения.

**Причина:** Вы не добавляете ответ ассистента в историю.

**Решение:**
```go
// ПЛОХО
messages = append(messages, userMessage)
resp := client.CreateChatCompletion(...)
answer := resp.Choices[0].Message.Content
// История не обновлена!

// ХОРОШО
messages = append(messages, userMessage)
resp := client.CreateChatCompletion(...)
messages = append(messages, resp.Choices[0].Message)  // Сохраняем ответ!
```
```

### 7. Мини-упражнения / Самопроверка (обязательно)

Практические задания для закрепления материала.

**Формат:**
```markdown
## Мини-упражнения

### Упражнение 1: [Название]

[Описание задания]

```go
// Шаблон кода для начала
```

**Ожидаемый результат:**
- [Критерий 1]
- [Критерий 2]
```

### 8. Чек-лист "Готово" (обязательно)

Список критериев, по которым читатель может проверить, что понял материал.

**Формат:**
```markdown
## Критерии сдачи / Чек-лист

✅ **Сдано:**
- [Критерий 1]
- [Критерий 2]

❌ **Не сдано:**
- [Типовая ошибка 1]
- [Типовая ошибка 2]
```

### 9. Для любопытных (опционально, но рекомендуется)

Формализация, математика, глубокие детали. Выносим в конец, чтобы не ломать основной поток.

**Формат:**
```markdown
## Для любопытных

> Этот раздел объясняет [что] на более глубоком уровне. Можно пропустить, если вас интересует только практика.

[Формализация, математика, детали реализации]
```

### 10. Связь с другими главами (обязательно)

Ссылки на связанные главы и лабораторные работы.

**Формат:**
```markdown
## Связь с другими главами

- **[Глава X: Название](../XX-chapter/README.md)** — [как связана]
- **[Lab XX: Название](../../labs/labXX-name/README.md)** — [практика]
```

### 11. Что дальше? (обязательно)

Навигация к следующей главе.

**Формат:**
```markdown
## Что дальше?

После изучения [темы] переходите к:
- **[XX. Следующая глава](../XX-next/README.md)** — [краткое описание]
```

## Правила простого языка

### Структура предложений

- **Короткие предложения** (до 20 слов)
- **Один факт на предложение**
- **Активный залог** ("Агент вызывает функцию" вместо "Функция вызывается агентом")

### Терминология

- **Сначала объясняем простыми словами**, потом используем термин
- **Единообразие терминов** — используем один термин для одного понятия
- **Англицизмы только при необходимости** — если есть хороший русский эквивалент, используем его

**Пример:**
```markdown
// ПЛОХО
Function Calling — это механизм вызова функций.

// ХОРОШО
Function Calling (вызов функций) — это механизм, при котором LLM возвращает не текст, а структурированный JSON с именем функции и аргументами.
```

### Примеры кода

**Правила:**
- **Минимальный пример сначала** — показываем самую простую рабочую версию
- **Затем расширяем** — добавляем сложность постепенно
- **Комментарии объясняют "почему"**, а не "что" (код самодокументирован)
- **Избегаем "простыней"** — если пример длинный, разбиваем на шаги

**Пример:**
```markdown
// Минимальный пример
```go
tools := []openai.Tool{
    {
        Type: openai.ToolTypeFunction,
        Function: &openai.FunctionDefinition{
            Name: "ping",
            Description: "Ping a host",
        },
    },
}
```

// Расширенный пример с валидацией
```go
tools := []openai.Tool{
    {
        Type: openai.ToolTypeFunction,
        Function: &openai.FunctionDefinition{
            Name:        "ping",
            Description: "Ping a host to check connectivity",
            Parameters: json.RawMessage(`{
                "type": "object",
                "properties": {
                    "host": {"type": "string"}
                },
                "required": ["host"]
            }`),
        },
    },
}
```
```

### Магия vs Реальность

Для объяснения сложных концепций используем паттерн "Магия vs Реальность":

**Формат:**
```markdown
### [Концепция] — Магия vs Реальность

**❌ Магия (как обычно объясняют):**
> [Упрощенное/неправильное объяснение]

**✅ Реальность (как на самом деле):**

[Детальное объяснение с примерами кода]
```

Это помогает:
- Развеять мифы и упрощения
- Показать реальный механизм работы
- Дать читателю правильное понимание

## Формат "Типовые ошибки"

Каждая ошибка должна следовать шаблону:

```markdown
### Ошибка N: [Краткое название]

**Симптом:** [Что видит пользователь]

**Причина:** [Почему это происходит]

**Решение:**
```go
// ПЛОХО
[Неправильный код]

// ХОРОШО
[Правильный код]
```
```

**Важно:**
- Начинаем с симптома (что видит пользователь)
- Объясняем причину (почему так происходит)
- Даем конкретное решение с кодом

## Формат "Мини-упражнения"

```markdown
## Мини-упражнения

### Упражнение N: [Название]

[Описание задания и контекста]

```go
// Шаблон кода (если нужен)
```

**Ожидаемый результат:**
- [Критерий 1]
- [Критерий 2]
```

## Формат "Чек-лист"

```markdown
## Критерии сдачи / Чек-лист

✅ **Сдано:**
- [Критерий 1]
- [Критерий 2]

❌ **Не сдано:**
- [Типовая ошибка 1]
- [Типовая ошибка 2]
```

## Примеры из разных доменов

**Правило:** Один главный сквозной сценарий (DevOps) + 1-2 коротких примера из других доменов только там, где это усиливает понимание.

**Когда добавлять примеры из других доменов:**
- Когда концепция универсальна и примеры из разных доменов показывают разные аспекты
- Когда нужно показать, что подход работает не только в DevOps

**Когда НЕ добавлять:**
- Если примеры дублируют друг друга
- Если это усложняет чтение без пользы

## Навигация между главами

В конце каждой главы:

```markdown
---

**Навигация:** [← Предыдущая глава](../XX-prev/README.md) | [Оглавление](../README.md) | [Следующая глава →](../XX-next/README.md)
```

## Заголовки

**Структура:**
- `#` — название главы (только в начале файла)
- `##` — основные разделы (Зачем, Теория, Алгоритм, и т.д.)
- `###` — подразделы (Ошибка 1, Упражнение 1, и т.д.)
- `####` — только если действительно нужно

**Правила:**
- Заголовки должны быть описательными, а не абстрактными
- Избегаем "Введение", "Заключение" — используем конкретные названия

## Диаграммы (Mermaid)

Используем диаграммы для визуализации:
- Архитектуры
- Алгоритмов
- Потоков данных

**Правила:**
- Диаграммы должны быть простыми и понятными
- Если диаграмма сложная, разбиваем на несколько простых
- Всегда добавляем текстовое описание под диаграммой

## Ссылки

**Формат:**
- На другие главы: `[Название](../XX-chapter/README.md)`
- На лабораторные: `[Lab XX: Название](../../labs/labXX-name/README.md)`
- На разделы: `[Название раздела](../XX-chapter/README.md#anchor)`

**Правила:**
- Всегда используем относительные пути
- Проверяем, что ссылки работают
- Используем описательные названия ссылок, а не "здесь" или "тут"

## Проверка перед коммитом

Перед коммитом проверьте:

- [ ] Структура соответствует шаблону главы
- [ ] Есть раздел "Зачем это нужно?"
- [ ] Есть реальный кейс
- [ ] Есть минимум 3 типовые ошибки
- [ ] Есть мини-упражнения
- [ ] Есть чек-лист
- [ ] Примеры кода минимальны и понятны
- [ ] Нет академического жаргона без объяснения
- [ ] Все ссылки работают
- [ ] Навигация в конце главы корректна

---

**См. также:** [`.cursor/rules.md`](../../.cursor/rules.md) — правила для Cursor AI

