# 06. RAG и База Знаний

## Зачем это нужно?

Обычный агент знает только то, чему его научили при тренировке (до даты cut-off). Он не знает ваши локальные инструкции типа "Как перезагружать сервер Phoenix согласно регламенту №5".

**RAG (Retrieval Augmented Generation)** — это механизм "подглядывания в шпаргалку". Агент сначала ищет информацию в базе знаний, а потом действует.

Без RAG агент не может использовать вашу документацию, регламенты и базу знаний. С RAG агент может найти нужную информацию и действовать согласно вашим инструкциям.

### Реальный кейс

**Ситуация:** Пользователь пишет: "Перезагрузи сервер Phoenix согласно регламенту"

**Проблема:** Агент не знает регламента перезагрузки сервера Phoenix. Он может выполнить стандартную перезагрузку, которая не соответствует вашим процедурам.

**Решение:** RAG позволяет агенту найти регламент в базе знаний перед выполнением действия. Агент находит документ "Регламент перезагрузки сервера Phoenix: 1. Выключить балансировщик 2. Перезагрузить сервер 3. Включить балансировщик" и следует этим шагам.

## Теория простыми словами

### Как работает RAG?

1. **Агент получает запрос** от пользователя
2. **Агент ищет информацию** в базе знаний через инструмент поиска
3. **База знаний возвращает** релевантные документы
4. **Агент использует информацию** для выполнения действия

## Как работает RAG? — Магия vs Реальность

**❌ Магия:**
> Агент "знает", что нужно поискать в базе знаний и сам находит нужную информацию

**✅ Реальность:**

### Полный протокол RAG

**Шаг 1: Запрос пользователя**

```go
messages := []openai.ChatCompletionMessage{
    {Role: "system", Content: "You are a DevOps assistant. Always search knowledge base before actions."},
    {Role: "user", Content: "Перезагрузи сервер Phoenix согласно регламенту"},
}
```

**Шаг 2: Модель видит описание инструмента поиска**

```go
tools := []openai.Tool{
    {
        Function: &openai.FunctionDefinition{
            Name: "search_knowledge_base",
            Description: "Search the knowledge base for documentation, protocols, and procedures. Use this BEFORE performing actions that require specific procedures.",
            Parameters: json.RawMessage(`{
                "type": "object",
                "properties": {
                    "query": {"type": "string", "description": "Search query"}
                },
                "required": ["query"]
            }`),
        },
    },
    {
        Function: &openai.FunctionDefinition{
            Name: "restart_server",
            Description: "Restart a server",
            Parameters: json.RawMessage(`{
                "type": "object",
                "properties": {
                    "hostname": {"type": "string"}
                },
                "required": ["hostname"]
            }`),
        },
    },
}
```

**Шаг 3: Модель генерирует tool call для поиска**

```go
resp1, _ := client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
    Model:    openai.GPT3Dot5Turbo,
    Messages: messages,
    Tools:    tools,
})

msg1 := resp1.Choices[0].Message
// msg1.ToolCalls = [{
//     Function: {
//         Name: "search_knowledge_base",
//         Arguments: "{\"query\": \"Phoenix restart protocol\"}"
//     }
// }]
```

**Почему модель сгенерировала tool_call на поиск?**
- System Prompt говорит: "Always search knowledge base before actions"
- Description инструмента говорит: "Use this BEFORE performing actions"
- Модель видит слово "регламенту" в запросе и связывает это с инструментом поиска

**Шаг 4: Runtime (ваш код) выполняет поиск**

> **Примечание:** Runtime — это код агента, который вы пишете на Go. См. [Главу 00: Предисловие](../00-preface/README.md#runtime-среда-выполнения) для определения.

```go
func searchKnowledgeBase(query string) string {
    // Простой поиск по ключевым словам (в продакшене - векторный поиск)
    knowledgeBase := map[string]string{
        "protocols.txt": "Регламент перезагрузки сервера Phoenix:\n1. Выключить балансировщик\n2. Перезагрузить сервер\n3. Включить балансировщик",
    }
    
    for filename, content := range knowledgeBase {
        if strings.Contains(strings.ToLower(content), strings.ToLower(query)) {
            return fmt.Sprintf("File: %s\nContent: %s", filename, content)
        }
    }
    return "No documents found"
}

result1 := searchKnowledgeBase("Phoenix restart protocol")
// result1 = "File: protocols.txt\nContent: Регламент перезагрузки сервера Phoenix:\n1. Выключить балансировщик..."
```

**Шаг 5: Результат поиска добавляется в контекст**

```go
messages = append(messages, openai.ChatCompletionMessage{
    Role:       "tool",
    Content:    result1,  // Вся найденная документация!
    ToolCallID: msg1.ToolCalls[0].ID,
})
// Теперь messages содержит:
// [system, user, assistant(tool_call: search_kb), tool("File: protocols.txt\nContent: ...")]
```

**Шаг 6: Модель видит документацию и действует**

```go
// Отправляем обновленную историю (с документацией!) в модель
resp2, _ := client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
    Model:    openai.GPT3Dot5Turbo,
    Messages: messages,  // Модель видит найденную документацию!
    Tools:    tools,
})

msg2 := resp2.Choices[0].Message
// Модель видит в контексте:
// "Регламент перезагрузки сервера Phoenix:\n1. Выключить балансировщик..."
// Модель генерирует tool calls согласно регламенту:

// msg2.ToolCalls = [
//     {Function: {Name: "restart_server", Arguments: "{\"hostname\": \"phoenix\"}"}},
//     // Или сначала выключить балансировщик, потом сервер
// ]
```

**Почему это не магия:**

1. **Модель не "знает" регламент** — она видит его в контексте после поиска
2. **Поиск — это обычный tool** — такой же, как `ping` или `restart_service`
3. **Результат поиска добавляется в `messages[]`** — модель видит его как новое сообщение
4. **Модель генерирует действия на основе контекста** — она видит документацию и следует ей

**Ключевой момент:** RAG — это не магия "знания", а механизм добавления релевантной информации в контекст модели через обычный tool call.

## Простой RAG vs Векторный поиск

В этой лабе мы реализуем **простой RAG** (поиск по ключевым словам). В продакшене используется **векторный поиск** (Semantic Search), который ищет по смыслу, а не по словам.

**Простой RAG (Lab 07):**
```go
// Поиск по вхождению подстроки
if strings.Contains(content, query) {
    return content
}
```

**Векторный поиск (продакшен):**
```go
// 1. Документы разбиваются на чанки и преобразуются в векторы (embeddings)
chunks := []Chunk{
    {ID: "chunk_1", Text: "Регламент перезагрузки Phoenix...", Embedding: [1536]float32{...}},
    {ID: "chunk_2", Text: "Шаг 2: Выключить балансировщик...", Embedding: [1536]float32{...}},
}

// 2. Запрос пользователя тоже преобразуется в вектор
queryEmbedding := embedQuery("Phoenix restart protocol")  // [1536]float32{...}

// 3. Поиск похожих векторов по косинусному расстоянию
similarDocs := vectorDB.Search(queryEmbedding, topK=3)
// Возвращает 3 наиболее похожих чанка по смыслу (не по словам!)

// 4. Результат добавляется в контекст модели так же, как в простом RAG
result := formatChunks(similarDocs)  // "Chunk 1: ...\nChunk 2: ...\nChunk 3: ..."
messages = append(messages, openai.ChatCompletionMessage{
    Role:    "tool",
    Content: result,
})
```

**Почему векторный поиск лучше:**
- Ищет по **смыслу**, а не по словам
- Найдет "restart Phoenix" даже если в документе написано "перезагрузка сервера Phoenix"
- Работает с синонимами и разными формулировками

## Чанкинг (Chunking)

Документы разбиваются на чанки (куски) для эффективного поиска.

**Пример:**
```
Документ: "Регламент перезагрузки сервера Phoenix..."
Чанк 1: "Регламент перезагрузки сервера Phoenix: шаг 1..."
Чанк 2: "Шаг 2: Выключить балансировщик..."
Чанк 3: "Шаг 3: Перезагрузить сервер..."
```

## Типовые ошибки

### Ошибка 1: Агент не ищет в базе знаний

**Симптом:** Агент выполняет действия без поиска в базе знаний, используя только общие знания.

**Причина:** System Prompt не инструктирует агента искать в базе знаний, или описание инструмента поиска недостаточно четкое.

**Решение:**
```go
// ХОРОШО: System Prompt требует поиск
systemPrompt := `... Always search knowledge base before performing actions that require specific procedures.`

// ХОРОШО: Четкое описание инструмента
Description: "Search the knowledge base for documentation, protocols, and procedures. Use this BEFORE performing actions that require specific procedures."
```

### Ошибка 2: Плохой поисковый запрос

**Симптом:** Агент не находит нужную информацию в базе знаний.

**Причина:** Поисковый запрос слишком общий или не содержит ключевых слов из документа.

**Решение:**
```go
// ПЛОХО: Слишком общий запрос
query := "server"

// ХОРОШО: Конкретный запрос с ключевыми словами
query := "Phoenix server restart protocol"
```

### Ошибка 3: Чанки слишком большие

**Симптом:** Поиск возвращает слишком большие документы, которые не влезают в контекст.

**Причина:** Размер чанков слишком большой (больше контекстного окна).

**Решение:**
```go
// ХОРОШО: Размер чанка ~500-1000 токенов
chunkSize := 500  // Токенов
```

## Мини-упражнения

### Упражнение 1: Реализуйте простой поиск

Реализуйте функцию простого поиска по ключевым словам:

```go
func searchKnowledgeBase(query string) string {
    // Простой поиск по ключевым словам
    // Верните релевантные документы
}
```

**Ожидаемый результат:**
- Функция находит документы, содержащие ключевые слова из запроса
- Функция возвращает первые N релевантных документов

### Упражнение 2: Реализуйте чанкинг

Реализуйте функцию разбиения документа на чанки:

```go
func chunkDocument(text string, chunkSize int) []string {
    // Разбейте документ на чанки размером chunkSize токенов
    // Верните список чанков
}
```

**Ожидаемый результат:**
- Функция разбивает документ на чанки заданного размера
- Чанки не перекрываются (или перекрываются минимально)

## Критерии сдачи / Чек-лист

✅ **Сдано:**
- Агент ищет в базе знаний перед выполнением действий
- Поисковые запросы конкретные и содержат ключевые слова
- Документы разбиты на чанки подходящего размера
- Инструмент поиска имеет четкое описание
- System Prompt инструктирует агента использовать базу знаний

❌ **Не сдано:**
- Агент не ищет в базе знаний (использует только общие знания)
- Поисковые запросы слишком общие (не находит нужную информацию)
- Чанки слишком большие (не влезают в контекст)

## Прод-заметки

При использовании RAG в продакшене учитывайте:

- **Версионирование документов:** Отслеживайте версии документов и дату обновления (`updated_at`). Это помогает понять, какая версия использовалась в ответе.
- **Freshness (актуальность):** Фильтруйте устаревшие документы (например, старше 30 дней) перед использованием в контексте.
- **Grounding:** Требуйте от агента ссылаться на найденные документы в ответе. Это снижает галлюцинации и повышает доверие.

Подробнее о прод-готовности: [Глава 19: Observability](../19-observability-and-tracing/README.md), [Глава 23: Evals в CI/CD](../23-evals-in-cicd/README.md).

## Связь с другими главами

- **Инструменты:** Как инструмент поиска интегрируется в агента, см. [Главу 03: Инструменты](../03-tools-and-function-calling/README.md)
- **Автономность:** Как RAG работает в цикле агента, см. [Главу 04: Автономность](../04-autonomy-and-loops/README.md)

## Что дальше?

После изучения RAG переходите к:
- **[07. Multi-Agent Systems](../07-multi-agent/README.md)** — как создать команду агентов

---

**Навигация:** [← Безопасность](../05-safety-and-hitl/README.md) | [Оглавление](../README.md) | [Multi-Agent →](../07-multi-agent/README.md)

