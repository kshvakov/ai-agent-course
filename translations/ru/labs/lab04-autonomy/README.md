# Lab 04: The Agent Loop (Autonomy)

## Цель
Собрать всё вместе: Мозг + Инструменты + Память. Реализовать паттерн **ReAct** (Reason + Act). Агент должен автономно решать задачу в цикле.

## Теория

### Planning (Планирование) — способность разбить задачу на шаги

**Planning** — это способность агента разбить сложную задачу на последовательность простых шагов и выполнить их в правильном порядке.

**Пример:**
- **Без планирования:** Агент получает "Кончилось место" и может сразу попытаться удалить файлы, не проверив, сколько места занято.
- **С планированием:** Агент сначала проверяет использование диска → видит 95% → решает очистить логи → проверяет снова → сообщает результат.

### ReAct (Reason + Act) — имплицитное планирование

В этой лабе мы реализуем **имплицитное планирование** через паттерн ReAct. Агент не создает явный план, а планирует "на лету" в процессе выполнения.

Автономный агент работает в цикле:
```
While (Задача не решена):
  1. Отправить историю в LLM.
  2. Получить ответ.
  3. ЕСЛИ это текст -> Показать пользователю и ждать нового ввода.
  4. ЕСЛИ это вызов инструмента -> 
       a. Выполнить инструмент.
       b. Добавить результат в историю.
       c. GOTO 1 (ничего не спрашивая у пользователя!).
```
Именно пункт 4.c дает "магию" — агент сам смотрит на результат и решает, что делать дальше.

**Как это работает:**
1. Агент получает задачу: "Кончилось место"
2. Агент думает: "Что мне нужно сделать первым? Проверить использование диска"
3. Агент выполняет: `check_disk_usage()`
4. Агент видит результат: "95%"
5. Агент думает: "Диск переполнен. Что делать дальше? Очистить логи"
6. Агент выполняет: `clean_logs()`
7. Агент видит результат: "Освобождено 20GB"
8. Агент думает: "Проверю снова, чтобы убедиться"
9. Агент выполняет: `check_disk_usage()`
10. Агент видит результат: "40%"
11. Агент думает: "Задача решена. Сообщу пользователю"

**Примечание:** Для более сложных задач (5+ шагов) используется **явное планирование** (Plan-and-Solve), которое мы изучим в Lab 06.

### Продвинутые темы

В книге рассмотрены дополнительные паттерны, которые расширяют базовый Agent Loop:

- **Parallel Tool Calls** — модель может вернуть несколько `tool_calls` за одну итерацию. Например, на запрос "Проверь статус nginx и postgresql" модель вернёт два вызова сразу. Runtime может выполнить их параллельно через `sync.WaitGroup`.
- **Multi-Model Agent Loop** — использование дешёвой модели (gpt-4o-mini) для выбора инструментов и генерации аргументов, а мощной (gpt-4o) для анализа результатов и финального ответа. Экономия до 50x на стоимости при 10 000+ задач в день.

Подробнее: [Глава 04: Автономность и Циклы](../../book/04-autonomy-and-loops/README.md)

## Задание
В `main.go` — большой каркас.

1.  **Tools:** У вас есть 2 инструмента: `check_disk_usage` (возвращает 95%) и `clean_logs` (освобождает место).
2.  **The Loop:** Реализуйте функцию `RunAgentLoop`. Она должна крутиться до тех пор, пока LLM не ответит обычным текстом.
3.  **Scenario:** Запустите агента с промптом: *"У меня кончилось место на сервере. Разберись."*
    *   Ожидание: Агент вызовет `check_disk_usage` -> увидит 95% -> сам решит вызвать `clean_logs` -> проверит снова -> скажет "Готово".

## Важно
Не забудьте обрабатывать ошибки и добавлять их в историю! Если инструмент упал, LLM должна это узнать и попробовать что-то другое.

