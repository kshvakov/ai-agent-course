# Методическое пособие: Lab 10 — Planning и Workflows

## Зачем это нужно?

В этой лабе вы реализуете **явное планирование** (Plan-and-Solve) — паттерн для сложных многошаговых задач. Агент сначала создает полный план, затем выполняет его шаг за шагом.

### Реальный кейс

**Ситуация:** Нужно развернуть новую версию сервиса.

**Без планирования:**
- Агент: [Сразу начинает деплой]
- Результат: Пропущена резервная копия БД
- Результат: Деплой в production без тестирования

**С планированием:**
- Агент создает план:
  1. Создать резервную копию БД
  2. Собрать новую версию
  3. Развернуть на staging
  4. Запустить тесты
  5. Развернуть в production
- Агент выполняет план по шагам
- Результат: Все шаги выполнены в правильном порядке

**Разница:** Планирование гарантирует выполнение всех необходимых шагов.

## Теория простыми словами

### Явное планирование vs Неявное планирование

**Неявное планирование (ReAct) — Lab 04:**
- Агент планирует "на лету" во время выполнения
- Подходит для простых задач (2-4 шага)
- Пример: "Проверить диск" → "Очистить логи" → "Проверить снова"

**Явное планирование (Plan-and-Solve) — Lab 10:**
- Агент сначала создает полный план
- Затем выполняет план шаг за шагом
- Подходит для сложных задач (5+ шагов)
- Пример: "План: 1. Проверить HTTP 2. Прочитать логи 3. Проанализировать 4. Исправить 5. Верифицировать"

### Декомпозиция задач

Сложные задачи нужно разбивать на подзадачи.

**Принципы декомпозиции:**
- **Атомарность:** Каждый шаг выполняется одним действием
  - ❌ Плохо: "Проверить и исправить сервер"
  - ✅ Хорошо: "Проверить статус" → "Прочитать логи" → "Применить исправление"

- **Зависимости:** Шаги выполняются в правильном порядке
  - ❌ Плохо: "Применить исправление" → "Прочитать логи"
  - ✅ Хорошо: "Прочитать логи" → "Проанализировать" → "Применить исправление"

- **Проверяемость:** У каждого шага есть четкий критерий успеха
  - ❌ Плохо: "Улучшить производительность"
  - ✅ Хорошо: "Снизить CPU с 95% до 50%"

### Разрешение зависимостей

Шаги могут зависеть друг от друга:
- Шаг B требует завершения Шага A
- Шаги могут выполняться параллельно, если нет зависимостей
- Циклические зависимости должны обнаруживаться и отклоняться

**Пример графа зависимостей:**
```
Step 1 (нет зависимостей) → можно выполнить сразу
Step 2 (зависит от Step 1) → ждет Step 1
Step 3 (зависит от Step 1) → ждет Step 1, но может выполняться параллельно с Step 2
Step 4 (зависит от Step 2 и Step 3) → ждет оба
```

### Сохранение состояния

Планы должны сохраняться на диск:
- Возобновление после прерывания
- Отслеживание прогресса
- Корректная обработка сбоев

## Алгоритм выполнения

### Шаг 1: Создание плана через LLM

```go
prompt := fmt.Sprintf(`Разбей задачу на шаги с зависимостями.
Задача: %s

Верни план в формате JSON:
{
  "steps": [
    {"id": "step1", "description": "...", "dependencies": []},
    {"id": "step2", "description": "...", "dependencies": ["step1"]}
  ]
}`, task)

resp, _ := client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
    Model: openai.GPT3Dot5Turbo,
    Messages: []openai.ChatCompletionMessage{
        {Role: "user", Content: prompt},
    },
})

// Парсим JSON ответ в структуру Plan
```

### Шаг 2: Поиск готовых шагов

```go
func findReadySteps(plan *Plan) []*Step {
    var ready []*Step
    for _, step := range plan.Steps {
        if step.Status != "pending" {
            continue
        }
        
        // Проверяем, все ли зависимости выполнены
        allDepsCompleted := true
        for _, depID := range step.Dependencies {
            dep := findStep(plan, depID)
            if dep.Status != "completed" {
                allDepsCompleted = false
                break
            }
        }
        
        if allDepsCompleted {
            ready = append(ready, step)
        }
    }
    return ready
}
```

### Шаг 3: Выполнение плана

```go
func executePlan(plan *Plan, executor StepExecutor) error {
    for {
        ready := findReadySteps(plan)
        if len(ready) == 0 {
            // Проверяем, все ли шаги выполнены
            if allStepsCompleted(plan) {
                return nil
            }
            return fmt.Errorf("deadlock: no ready steps, but plan not completed")
        }
        
        // Выполняем готовые шаги
        for _, step := range ready {
            step.Status = "running"
            result, err := executor.Execute(step)
            if err != nil {
                step.Status = "failed"
                return err
            }
            step.Status = "completed"
            step.Result = result
        }
    }
}
```

### Шаг 4: Сохранение состояния

```go
func savePlanState(planID string, plan *Plan) error {
    data, err := json.Marshal(plan)
    if err != nil {
        return err
    }
    return os.WriteFile(fmt.Sprintf("plan_%s.json", planID), data, 0644)
}
```

## Типовые ошибки

### Ошибка 1: Не проверяются зависимости

**Симптом:** Шаги выполняются в неправильном порядке.

**Причина:** Не проверяются зависимости перед выполнением.

**Решение:** Всегда вызывайте `findReadySteps()` перед выполнением.

### Ошибка 2: Циклические зависимости не обнаруживаются

**Симптом:** План зависает, нет готовых шагов.

**Причина:** Циклические зависимости не обнаружены на этапе создания плана.

**Решение:** Проверяйте циклы при создании плана или перед выполнением.

### Ошибка 3: Нет сохранения состояния

**Симптом:** При прерывании весь прогресс теряется.

**Причина:** Состояние не сохраняется.

**Решение:** Сохраняйте план после каждого выполненного шага.

## Критерии сдачи

✅ **Сдано:**
- План создается через LLM
- Зависимости проверяются перед выполнением
- Циклические зависимости обнаруживаются
- Состояние сохраняется в файл
- План можно возобновить после прерывания

❌ **Не сдано:**
- Шаги выполняются без проверки зависимостей
- Циклические зависимости не обнаруживаются
- Нет сохранения состояния
- План нельзя возобновить

