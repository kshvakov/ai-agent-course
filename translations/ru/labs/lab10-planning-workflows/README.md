# Lab 10: Planning и Workflows

## Goal
Научиться реализовывать паттерны планирования: декомпозицию задач, разрешение зависимостей, выполнение плана с повторными попытками и сохранение состояния.

## Theory

### Паттерны планирования

Когда агенты обрабатывают сложные многошаговые задачи, им нужно планирование:
- **Декомпозиция задач** — Разбить большую задачу на шаги
- **Граф зависимостей** — Понять зависимости между шагами
- **Порядок выполнения** — Выполнять шаги с учетом зависимостей
- **Отслеживание состояния** — Знать, что сделано, что ожидает
- **Обработка ошибок** — Повтор, пропуск или прерывание при ошибках

### Явное планирование vs Неявное планирование

**Неявное планирование (ReAct) — Lab 04:**
- Агент планирует "на лету" во время выполнения
- Подходит для простых задач (2-4 шага)
- Пример: "Проверить диск" → "Очистить логи" → "Проверить снова"

**Явное планирование (Plan-and-Solve) — Lab 10:**
- Агент сначала создает полный план
- Затем выполняет план шаг за шагом
- Подходит для сложных задач (5+ шагов)
- Пример: "План: 1. Проверить HTTP 2. Прочитать логи 3. Проанализировать 4. Исправить 5. Верифицировать"

### Разрешение зависимостей

Шаги могут зависеть друг от друга:
- Шаг B требует завершения Шага A
- Шаги могут выполняться параллельно, если нет зависимостей
- Циклические зависимости должны обнаруживаться и отклоняться

### Сохранение состояния

Планы должны сохраняться на диск:
- Возобновление после прерывания
- Отслеживание прогресса
- Корректная обработка сбоев

См. подробнее: [Глава 10: Planning и Workflow-паттерны](../../book/10-planning-and-workflows/README.md)

## Task

В `main.go` реализуйте систему планирования для сложных задач.

### Часть 1: Декомпозиция задач

Реализуйте функцию `createPlan(task string) (*Plan, error)`:
- Используйте LLM для декомпозиции задачи на шаги
- Определите зависимости между шагами
- Верните Plan с шагами и зависимостями

**Пример:**
```
Задача: "Развернуть новую версию сервиса"
План:
  Шаг 1: Создать резервную копию БД (нет зависимостей)
  Шаг 2: Собрать новую версию (зависит от: Шаг 1)
  Шаг 3: Развернуть на staging (зависит от: Шаг 2)
  Шаг 4: Запустить тесты (зависит от: Шаг 3)
  Шаг 5: Развернуть в production (зависит от: Шаг 4)
```

### Часть 2: Разрешение зависимостей

Реализуйте функцию `findReadySteps(plan *Plan) []*Step`:
- Верните шаги, все зависимости которых выполнены
- Обработайте циклические зависимости (обнаружить и вернуть ошибку)
- Поддержите параллельное выполнение независимых шагов

### Часть 3: Выполнение плана с повторными попытками

Реализуйте функцию `executePlanWithRetries(plan *Plan, executor StepExecutor, maxRetries int) error`:
- Выполняйте шаги с учетом зависимостей
- Повторяйте неудачные шаги до maxRetries
- Корректно обрабатывайте ошибки (пропустить, прервать или повторить)
- Отслеживайте статус шагов (ожидает, выполняется, завершен, ошибка)

### Часть 4: Сохранение состояния

Реализуйте функцию `savePlanState(planID string, plan *Plan) error`:
- Сохраните состояние плана в файл (формат JSON)
- Включите возобновление плана после прерывания
- Загрузите состояние плана из файла

## Important

- Всегда проверяйте зависимости перед выполнением шагов
- Корректно обрабатывайте ошибки (повтор, пропуск или прерывание)
- Сохраняйте состояние после завершения каждого шага
- Обнаруживайте и отклоняйте циклические зависимости

## Completion Criteria

✅ **Сдано:**
- Декомпозиция задач реализована
- Разрешение зависимостей работает корректно
- Выполнение плана с повторными попытками
- Сохранение состояния реализовано
- Можно возобновить прерванные планы
- Циклические зависимости обнаруживаются

❌ **Не сдано:**
- Шаги выполняются без проверки зависимостей
- Нет сохранения состояния
- Бесконечные повторы без ограничений
- Циклические зависимости не обнаруживаются

---

**Следующий шаг:** После завершения Lab 10 переходите к [Lab 11: Memory и Context Management](../lab11-memory-context/README.md).
