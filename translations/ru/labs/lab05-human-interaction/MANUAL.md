# Методическое пособие: Lab 05 — Human-in-the-Loop

## Зачем это нужно?

Автономность не означает вседозволенность. Есть два сценария, когда агент **обязан** вернуть управление человеку:

1. **Уточнение (Clarification):** Пользователь поставил задачу нечетко
2. **Подтверждение (Confirmation):** Действие слишком опасное

### Реальный кейс

**Ситуация 1 (Уточнение):**
- User: "Отправь письмо боссу"
- Agent: "Какая тема и текст письма?" ← Агент спрашивает уточнение
- User: "Тема: Отчет, текст: Все готово"
- Agent: [Отправляет письмо]

**Ситуация 2 (Подтверждение):**
- User: "Удали базу данных prod"
- Agent: "Вы уверены? Это удалит все данные в продакшене. Введите 'yes' для подтверждения." ← Агент запрашивает подтверждение
- User: "yes"
- Agent: [Удаляет базу]

**Без Human-in-the-Loop:** Агент мог бы удалить базу без подтверждения, что привело бы к катастрофе.

## Теория простыми словами

### Объединение циклов (Nested Loops)

Мы используем структуру вложенных циклов:

- **Внешний цикл (`While True`):** Отвечает за общение с пользователем. Читает `stdin`.
- **Внутренний цикл (Agent Loop):** Отвечает за "мышление". Крутится до тех пор, пока агент вызывает инструменты. Как только агент выдает текст — мы выходим во внешний цикл.

**Схема:**

```
Внешний цикл (Chat):
  Читаем ввод пользователя
  Внутренний цикл (Agent):
    Пока агент вызывает инструменты:
      Выполняем инструмент
      Продолжаем внутренний цикл
    Если агент ответил текстом:
      Показываем пользователю
      Выходим из внутреннего цикла
  Ждем следующего ввода пользователя
```

### System Prompt как Правила Безопасности

Мы явно прописываем в системном промпте: *"Always ask for explicit confirmation before deleting anything"*.

LLM (особенно GPT-4) хорошо следует этому правилу. Вместо генерации `ToolCall("delete_db")` она генерирует текст *"Are you sure you want to delete...?"*.

Поскольку это текст, внутренний цикл прерывается, и вопрос показывается пользователю.

### Продолжение разговора

Когда пользователь отвечает *"Yes"*, мы добавляем это в историю и снова запускаем агента. Теперь у него в контексте есть:
1. User: "Delete DB"
2. Assistant: "Are you sure?"
3. User: "Yes"

Агент видит подтверждение и на этот раз генерирует `ToolCall("delete_db")`.

## Алгоритм выполнения

### Шаг 1: Определение критических инструментов

```go
tools := []openai.Tool{
    {
        Type: openai.ToolTypeFunction,
        Function: &openai.FunctionDefinition{
            Name:        "delete_db",
            Description: "Delete a database by name. DANGEROUS ACTION.",
            // ...
        },
    },
}
```

**Важно:** В `Description` указывайте, что действие опасное.

### Шаг 2: System Prompt с правилами безопасности

```go
systemPrompt := `You are a helpful assistant.
IMPORTANT:
1. Always ask for explicit confirmation before deleting anything.
2. If user parameters are missing, ask clarifying questions.`
```

### Шаг 3: Вложенные циклы

```go
// Внешний цикл (Chat)
for {
    // Читаем ввод пользователя
    input := readUserInput()
    messages = append(messages, userMessage)
    
    // Внутренний цикл (Agent)
    for {
        resp := client.CreateChatCompletion(...)
        msg := resp.Choices[0].Message
        messages = append(messages, msg)
        
        if len(msg.ToolCalls) == 0 {
            // Агент ответил текстом (вопрос или финальный ответ)
            fmt.Println("Agent:", msg.Content)
            break  // Выходим из внутреннего цикла
        }
        
        // Выполняем инструменты
        for _, toolCall := range msg.ToolCalls {
            result := executeTool(toolCall)
            messages = append(messages, toolResult)
        }
        // Продолжаем внутренний цикл
    }
    // Ждем следующего ввода пользователя
}
```

## Типовые ошибки

### Ошибка 1: Агент не спрашивает подтверждение

**Симптом:** Агент сразу удаляет базу без подтверждения.

**Причина:** System Prompt недостаточно строгий или модель его игнорирует.

**Решение:**
1. Усильте System Prompt: "CRITICAL: Never delete without explicit confirmation"
2. Используйте модель помощнее (GPT-4 вместо GPT-3.5)
3. Добавьте Few-Shot примеры в промпт

### Ошибка 2: Агент не уточняет параметры

**Симптом:** Агент пытается вызвать инструмент с неполными аргументами.

**Пример:**
```
User: "Отправь письмо"
Agent: [Пытается вызвать send_email без темы и текста]
```

**Решение:**
```go
// В System Prompt:
"If required parameters are missing, ask the user for them. Do not guess."
```

### Ошибка 3: Подтверждение не работает

**Симптом:** Пользователь подтвердил, но агент снова спрашивает.

**Причина:** Подтверждение не добавлено в историю или добавлено неправильно.

**Решение:**
```go
// После подтверждения пользователя:
messages = append(messages, ChatCompletionMessage{
    Role:    "user",
    Content: "yes",  // Подтверждение
})
// Теперь агент увидит подтверждение в контексте
```

## Мини-упражнения

### Упражнение 1: Добавьте риск-скоринг

Реализуйте функцию, которая определяет уровень риска действия:

```go
func calculateRisk(toolName string) float64 {
    risks := map[string]float64{
        "delete_db": 0.9,
        "restart_service": 0.3,
        "read_logs": 0.0,
    }
    return risks[toolName]
}
```

### Упражнение 2: Разные уровни подтверждения

Реализуйте разные типы подтверждений для разных уровней риска:

```go
if risk > 0.8 {
    // Критическое действие: требуем явного "yes"
} else if risk > 0.5 {
    // Средний риск: достаточно простого подтверждения
} else {
    // Низкий риск: можно выполнять без подтверждения
}
```

## Критерии сдачи

✅ **Сдано:**
- Агент спрашивает подтверждение перед опасными действиями
- Агент уточняет параметры, если они отсутствуют
- Подтверждение работает корректно
- Вложенные циклы реализованы правильно

❌ **Не сдано:**
- Агент не спрашивает подтверждение
- Агент не уточняет параметры
- Подтверждение не работает

---

**Следующий шаг:** После успешного прохождения Lab 05 переходите к [Lab 06: Incident Management](../lab06-incident/README.md)

